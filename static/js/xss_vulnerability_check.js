/**
 * XSS Vulnerability Scanner
 * Tests if the current page might be vulnerable to Cross-Site Scripting attacks
 */
class XSSVulnerabilityChecker {
    constructor() {
        this.results = {
            tested: false,
            vulnerabilityDetected: false,
            potentialVulnerabilities: [],
            securityMeasures: {
                contentSecurityPolicy: false,
                xssProtection: false,
                noSniff: false
            },
            riskLevel: 'Low'
        };
    }

    /**
     * Check for XSS vulnerabilities
     * @returns {Object} Results of the XSS vulnerability check
     */
    async checkVulnerabilities() {
        try {
            this.results.tested = true;
            
            // Check security headers
            this.checkSecurityHeaders();
            
            // Check for unsafe DOM practices
            this.checkUnsafeDOMPractices();
            
            // Check URL parameter handling
            this.checkURLParameters();
            
            // Calculate risk level
            this.calculateRiskLevel();
            
            return this.results;
            
        } catch (error) {
            console.error('XSS vulnerability check error:', error);
            this.results.error = error.message;
            return this.results;
        }
    }

    /**
     * Check if the site is using recommended security headers
     */
    checkSecurityHeaders() {
        // In a real implementation, you would need to check the headers on the server side
        // Here we simulate the check with some reasonable assumptions
        
        // For Content-Security-Policy, we can check if it's being used via meta tag
        const cspMetaTag = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
        this.results.securityMeasures.contentSecurityPolicy = !!cspMetaTag;
        
        // The rest of the headers we can't check reliably client-side,
        // but for demonstration purposes, we'll note this limitation
        this.results.headerCheckLimited = true;
        this.results.potentialVulnerabilities.push({
            type: 'Missing Security Headers Check',
            description: 'Cannot fully check security headers from client-side JavaScript',
            recommendation: 'Use a server-side tool to verify all security headers are properly set'
        });
    }

    /**
     * Check for unsafe DOM practices that could lead to XSS
     */
    checkUnsafeDOMPractices() {
        // Check for unsafe assignments to innerHTML
        const dangerousPatterns = this.findDangerousPatterns();
        
        if (dangerousPatterns.length > 0) {
            this.results.vulnerabilityDetected = true;
            this.results.potentialVulnerabilities.push({
                type: 'Unsafe DOM Manipulation',
                description: 'Potentially unsafe DOM manipulation methods detected',
                details: dangerousPatterns,
                recommendation: 'Use safer alternatives like textContent instead of innerHTML, or sanitize input'
            });
        }
        
        // Check for eval and other unsafe functions
        const evalUsage = this.findEvalUsage();
        if (evalUsage) {
            this.results.vulnerabilityDetected = true;
            this.results.potentialVulnerabilities.push({
                type: 'Unsafe JavaScript Execution',
                description: 'The use of eval() or similar unsafe functions detected',
                recommendation: 'Avoid using eval() and Function constructor when possible'
            });
        }
    }

    /**
     * Find potentially dangerous patterns in the DOM
     * @returns {Array} List of dangerous patterns found
     */
    findDangerousPatterns() {
        const dangerous = [];
        
        // Look for script tags where we probably shouldn't have them
        const inlineScripts = document.querySelectorAll('script:not([src])');
        if (inlineScripts.length > 0) {
            dangerous.push({
                pattern: 'Inline scripts',
                count: inlineScripts.length,
                risk: 'Medium'
            });
        }
        
        // For demonstration - in reality, this would be much more comprehensive
        // and would need to examine the actual code execution
        
        return dangerous;
    }

    /**
     * Look for eval usage in the page
     * @returns {boolean} Whether eval usage was detected
     */
    findEvalUsage() {
        // This is a simplified check and is limited by browser security
        // In practice, this would be very difficult to accurately detect client-side
        // A real implementation would need to scan the source code
        
        // Attempting to detect eval() usage in inline scripts
        let evalDetected = false;
        const inlineScripts = document.querySelectorAll('script:not([src])');
        
        inlineScripts.forEach(script => {
            if (script.textContent.includes('eval(')) {
                evalDetected = true;
            }
        });
        
        return evalDetected;
    }

    /**
     * Check URL parameters for possible XSS vectors
     */
    checkURLParameters() {
        const url = new URL(window.location.href);
        const params = url.searchParams;
        
        if (params.size === 0) {
            return;  // No parameters to check
        }
        
        // Check each parameter for suspicious content
        let suspiciousParamsFound = false;
        const suspiciousParams = [];
        
        params.forEach((value, key) => {
            // Check for script tags, javascript: protocol, or other suspicious patterns
            const suspiciousPatterns = [
                /<script>/i,
                /<\/script>/i,
                /javascript:/i,
                /<img[^>]+onerror=/i,
                /on\w+=/i, // onclick, onload, etc.
            ];
            
            for (const pattern of suspiciousPatterns) {
                if (pattern.test(value)) {
                    suspiciousParamsFound = true;
                    suspiciousParams.push({ key, value });
                    break;
                }
            }
        });
        
        if (suspiciousParamsFound) {
            this.results.vulnerabilityDetected = true;
            this.results.potentialVulnerabilities.push({
                type: 'Suspicious URL Parameters',
                description: 'URL parameters contain potentially unsafe content',
                details: suspiciousParams,
                recommendation: 'Ensure all input is properly sanitized before using in DOM'
            });
        }
    }

    /**
     * Calculate the overall XSS risk level
     */
    calculateRiskLevel() {
        if (this.results.vulnerabilityDetected) {
            // Count high severity issues
            const highSeverityCount = this.results.potentialVulnerabilities.filter(
                v => v.type === 'Unsafe JavaScript Execution'
            ).length;
            
            if (highSeverityCount > 0) {
                this.results.riskLevel = 'High';
            } else if (this.results.potentialVulnerabilities.length > 1) {
                this.results.riskLevel = 'Medium';
            } else {
                this.results.riskLevel = 'Low';
            }
        } else {
            this.results.riskLevel = 'Low';
        }
        
        // Factor in security headers
        const securityMeasures = this.results.securityMeasures;
        if (!securityMeasures.contentSecurityPolicy && !securityMeasures.xssProtection) {
            // Increase risk level if missing important security headers
            if (this.results.riskLevel === 'Low') {
                this.results.riskLevel = 'Medium';
            }
        }
    }
}